MODULE GROUP DOCUMENTATION:


The information about what to render on the webpage is stored in the tables of the database.
This is needed, because the user of the webpage might want to change a couple of things,
so certain areas of the webpage are not hardcoded, but depend on what the user decides to input on the admin app.
These changes are then applied via an API to the database, from where the webpage will pick up the information.
The server connects to the database with the module databaseConnection.js.


When the server wants to get data from the database, it has to make a query.
The query takes time to finish, which is why it is wrapped inside an asynchronous function.
Whenever this function is called, the await keyword must be used,
otherwise the code will continue running without having access to the returned data.
This function can be found in the module queryDatabase.js.


From the database query an array of results is returned to the server.
Each item in this array represents an entry in the database and usually has several properties.
To use this array directly for rendering the content of the webpage would be impractical
and it is makes much more sense to turn this array into semantically meaningful javascript objects.

There is a lot of content to be rendered on the webpage however, and coding up each element separately would be very verbose,
especially because most of those javascript objects will be very similar and share the same structure.
Thus, models can be written, which will act as templates for creating these javascript objects.
To create these models, it is convenient to use constructor functions, which can be found in the module modelConstructors.js.


To make using this newly-created javascript content even easier,
the elements created with the same model can be compiled into a larger container.
So whenever this content needs to be passed to a route for example,
all of the necessary objects don't have to be passed in separately, but a container can be used instead.

All renderable objects on this webpage can be changed by the user by making changes to the database via an API,
but in many cases, the user also needs to add new objects or delete existing ones.
The objects that can be created or deleted by the user, will be referred to as "dynamic".
Those that can only be updated, but not deleted or replicated, will be called "static".

In the module modelCompiler.js there are two methods, which create the containers.
For static content, the container will be a javascript object and each element will become a named property on this container.
The names for dynamic objects are generated by the server however (because they can be created and deleted), and cannot be known in advance.
The container for dynamic objects will be an array instead,
and since they cannot be referenced by a name, they are accessible by indices.


With static content, the compiler function needs to have access to the names of the objects it wants to compile.
These names are stored in the module keyArrays.js (as arrays).
With dynamic content, the names don't actually matter, but the function needs to know how many items it has to put into an array.
The same module keyArrays.js has a function that queries a specified database table for the server-generated names.
When these names are returned from the database, the compiler function determines the quantity of these names
and returns a container array with the same length.


Now that the containers have been compiled, they can be requested by a route in the server using the module requestData.js.
The function returned by this module is basically only a simplifier that refers to the correct module at the right time.

The server passes in four arguments to this function:
1) a target string,
2) the name of a model constructor,
3) a boolean that determines whether the requested data is dynamic,
4) the language used in the route.


The target string is a simplified string and will be converted into two important pieces of data:
Firstly the name of the database table, that the server wants to make a query to,
and secondly a variable name which will locate the relevant array in the keyArrays module.

The name of the model constructor will be used to locate the correct constructor in the modelConstructors module.

The database name will be passed into the queryDatabase module, which will return an array of results.
Depending on whether the requested data is dynamic or static, one of the modelCompiler methods will be called.
The array of results will be passed into this method, along with the obtained model constructor,
as well as the array of key names and the language specification.

Inside the compiler, the specified model constructor is used to create new renderable javascript objects,
the number (and names) of which are specified in the provided array of key names.
Some objects also need a language specification, which is also provided by the server.

The compiler returns a container object or a container array, which can be passed into the server routes to be rendered on the webpage.
