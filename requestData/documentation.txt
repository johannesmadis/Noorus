MODULE GROUP DOCUMENTATION:


The information about what to render on the webpage is stored in the tables of the database.
This is needed, because the user of the webpage might want to change a couple of things,
so certain areas of the webpage are not hardcoded, but depend on what the user decides to input via the admin app.
These changes are then applied via an API to the database, from where the webpage will pick up the information.
The server connects to the database using the module DBConnection.js.


When the server wants to get data from the database, it has to make a query.
The query takes time to finish, which is why it is wrapped inside an asynchronous function.
Whenever this function is called, the await keyword must be used,
otherwise the code will continue running without having access to the returned data.
This function can be found in the module queryDB.js.


From the database query an array of results is returned to the server.
Each item in this array represents an entry in the database and usually has several properties.
To use this array directly for rendering the content of the webpage would be impractical however,
and it is makes much more sense to turn this array into semantically meaningful javascript objects.

There is a lot of content to be rendered on the webpage, and coding up each element separately would be very verbose,
especially because most of those renderable javascript objects will be very similar and share the same structure.
Thus, models could be written, which will act as templates for creating these javascript objects.
To create these models, it is convenient to use constructor functions, which can be found in models.js.


To make using this newly-created javascript content even easier,
the elements created with the same model can be compiled into a larger container- an array.
So whenever this content needs to be passed to a route for example,
all of the renderable objects don't have to be passed in separately, but the container array can be used instead.


The module compiler.js has access to both models.js and queryDB.js and makes these two work together.
The outcome is a bunch of javascript objects that have the structure of the specified model and the content of the specified database table.
All of the objects that originate from the same database table will be pushed into their own container array, which is then returned.


There are also some parts on each route template that do not originate from any database, but which on first look aren't hardcoded either.
This is because each template is usually used by two routes- one for Estonian and one for English version of the page.
This means that even some of the content that is not meant to be changed is still passed in as javascript variables.
The route in the server file only provides information about the language and the variables on the template will get a corresponding value.
The raw hardcoded data that gets passed into the variables is stored in the module routeInfo.js.


The last piece before the server can get access to the content it wants to render is the module reqData.js.
This module has access to both the database data via compiler.js and the hardcoded content in routeInfo.js.
The module compiles all of that together and returns one data container for each template.
A route in the server side only needs to pass in the name of the template and the language it uses
and in return it gets access to a huge javascript object full of all the content that the route needs to display a webpage.
